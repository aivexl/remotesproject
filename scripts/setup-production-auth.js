#!/usr/bin/env node

// =============================================================================
// ENTERPRISE PRODUCTION AUTHENTICATION SETUP SCRIPT
// =============================================================================
// Fortune 500 Enterprise Standard - Zero Tolerance for Authentication Failures
// MIT-level Technical Excellence with IBM/Google CTO Experience
// =============================================================================

const fs = require('fs');
const path = require('path');
const https = require('https');
const { execSync } = require('child_process');

class ProductionAuthSetup {
  constructor() {
    this.config = {};
    this.issues = [];
    this.warnings = [];
    this.successes = [];
    this.startTime = Date.now();
  }

  log(level, message, data = null) {
    const timestamp = new Date().toISOString();
    const colors = {
      INFO: '\x1b[36m',
      SUCCESS: '\x1b[32m',
      WARNING: '\x1b[33m',
      ERROR: '\x1b[31m',
      CRITICAL: '\x1b[35m',
      RESET: '\x1b[0m'
    };

    const color = colors[level] || colors.RESET;
    console.log(`${color}[${level}]\x1b[0m ${message}`);

    if (data && process.argv.includes('--verbose')) {
      console.log(`${color}Data:\x1b[0m`, JSON.stringify(data, null, 2));
    }
  }

  async loadConfig() {
    this.log('INFO', 'Loading configuration...');

    // Load from environment variables
    this.config = {
      NODE_ENV: process.env.NODE_ENV || 'production',
      NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
      NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
      SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,
      NEXT_PUBLIC_PRODUCTION_DOMAIN: process.env.NEXT_PUBLIC_PRODUCTION_DOMAIN || 'https://belugagithubv2025machineloopscorpsf-gold.vercel.app',
      NEXT_PUBLIC_DEVELOPMENT_DOMAIN: process.env.NEXT_PUBLIC_DEVELOPMENT_DOMAIN || 'http://localhost:3000',
      GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID,
      GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET,
      NEXT_PUBLIC_APP_ENV: process.env.NEXT_PUBLIC_APP_ENV || 'production'
    };

    this.log('SUCCESS', 'Configuration loaded');
    return this.config;
  }

  validateConfig() {
    this.log('INFO', 'Validating configuration...');

    const required = [
      'NEXT_PUBLIC_SUPABASE_URL',
      'NEXT_PUBLIC_SUPABASE_ANON_KEY',
      'NEXT_PUBLIC_PRODUCTION_DOMAIN'
    ];

    const productionRequired = [
      'SUPABASE_SERVICE_ROLE_KEY'
    ];

    let isValid = true;

    // Check required variables
    for (const key of required) {
      if (!this.config[key]) {
        this.issues.push(`Missing required environment variable: ${key}`);
        isValid = false;
      }
    }

    // Check production-specific variables
    if (this.config.NODE_ENV === 'production') {
      for (const key of productionRequired) {
        if (!this.config[key]) {
          this.issues.push(`Missing required production environment variable: ${key}`);
          isValid = false;
        }
      }
    }

    // Validate URLs
    if (this.config.NEXT_PUBLIC_PRODUCTION_DOMAIN) {
      if (!this.config.NEXT_PUBLIC_PRODUCTION_DOMAIN.startsWith('https://')) {
        this.issues.push('Production domain must use HTTPS');
        isValid = false;
      }

      if (this.config.NEXT_PUBLIC_PRODUCTION_DOMAIN.includes('localhost')) {
        this.issues.push('Production domain should not be localhost');
        isValid = false;
      }
    }

    // Validate Supabase URL format
    if (this.config.NEXT_PUBLIC_SUPABASE_URL) {
      if (!this.config.NEXT_PUBLIC_SUPABASE_URL.includes('supabase.co')) {
        this.warnings.push('Supabase URL format looks unusual');
      }
    }

    if (isValid) {
      this.log('SUCCESS', 'Configuration validation passed');
      this.successes.push('All required environment variables are configured');
    } else {
      this.log('ERROR', 'Configuration validation failed');
    }

    return isValid;
  }

  createEnvFile() {
    this.log('INFO', 'Creating production environment file...');

    const envTemplate = `# =============================================================================
# ENTERPRISE AUTHENTICATION SYSTEM - PRODUCTION CONFIGURATION
# Generated by Production Auth Setup Script
# Timestamp: ${new Date().toISOString()}
# =============================================================================

# SUPABASE CONFIGURATION (Primary Authentication Service)
NEXT_PUBLIC_SUPABASE_URL=${this.config.NEXT_PUBLIC_SUPABASE_URL || ''}
NEXT_PUBLIC_SUPABASE_ANON_KEY=${this.config.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''}
SUPABASE_SERVICE_ROLE_KEY=${this.config.SUPABASE_SERVICE_ROLE_KEY || ''}

# CRITICAL: PRODUCTION DOMAIN CONFIGURATION
NEXT_PUBLIC_PRODUCTION_DOMAIN=${this.config.NEXT_PUBLIC_PRODUCTION_DOMAIN}
NEXT_PUBLIC_DEVELOPMENT_DOMAIN=${this.config.NEXT_PUBLIC_DEVELOPMENT_DOMAIN}

# AUTHENTICATION SECURITY SETTINGS
AUTH_SESSION_REFRESH_THRESHOLD=300000
AUTH_MAX_LOGIN_ATTEMPTS=5
AUTH_LOCKOUT_DURATION=600000
AUTH_PASSWORD_MIN_LENGTH=8
AUTH_RATE_LIMIT_WINDOW=900000
AUTH_MAX_REQUESTS_PER_WINDOW=10

# GOOGLE OAUTH CONFIGURATION (Optional)
GOOGLE_CLIENT_ID=${this.config.GOOGLE_CLIENT_ID || ''}
GOOGLE_CLIENT_SECRET=${this.config.GOOGLE_CLIENT_SECRET || ''}

# SECURITY HEADERS & CORS
NEXT_PUBLIC_ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001,${this.config.NEXT_PUBLIC_PRODUCTION_DOMAIN}
CORS_MAX_AGE=86400

# ENVIRONMENT IDENTIFICATION
NODE_ENV=${this.config.NODE_ENV}
NEXT_PUBLIC_APP_ENV=${this.config.NEXT_PUBLIC_APP_ENV}

# PERFORMANCE OPTIMIZATION
NEXT_PUBLIC_ENABLE_SERVICE_WORKER=true
NEXT_PUBLIC_ENABLE_PWA=true
NEXT_PUBLIC_ENABLE_OFFLINE_MODE=true

# FEATURE FLAGS
NEXT_PUBLIC_ENABLE_BIOMETRIC_AUTH=false
NEXT_PUBLIC_ENABLE_2FA=false
NEXT_PUBLIC_ENABLE_SOCIAL_LOGIN=${this.config.GOOGLE_CLIENT_ID ? 'true' : 'false'}

# DEVELOPMENT TOOLS
NEXT_PUBLIC_ENABLE_DEBUG_MODE=false
NEXT_PUBLIC_ENABLE_PERFORMANCE_MONITORING=true

# PRODUCTION MONITORING
NEXT_PUBLIC_SENTRY_DSN=${process.env.NEXT_PUBLIC_SENTRY_DSN || ''}
NEXT_PUBLIC_GA_MEASUREMENT_ID=${process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID || ''}
`;

    const envPath = path.join(process.cwd(), '.env.local');

    // Backup existing file if it exists
    if (fs.existsSync(envPath)) {
      const backupPath = `${envPath}.backup.${Date.now()}`;
      fs.copyFileSync(envPath, backupPath);
      this.log('INFO', `Backed up existing .env.local to ${backupPath}`);
    }

    try {
      fs.writeFileSync(envPath, envTemplate);
      this.log('SUCCESS', 'Production environment file created: .env.local');
      this.successes.push('Environment file configured successfully');
    } catch (error) {
      this.issues.push(`Failed to create environment file: ${error.message}`);
      return false;
    }

    return true;
  }

  async testSupabaseConnection() {
    this.log('INFO', 'Testing Supabase connection...');

    if (!this.config.NEXT_PUBLIC_SUPABASE_URL || !this.config.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
      this.issues.push('Cannot test Supabase connection: missing URL or API key');
      return false;
    }

    return new Promise((resolve) => {
      const url = `${this.config.NEXT_PUBLIC_SUPABASE_URL}/rest/v1/`;

      const req = https.request(url, {
        headers: {
          'apikey': this.config.NEXT_PUBLIC_SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${this.config.NEXT_PUBLIC_SUPABASE_ANON_KEY}`,
          'User-Agent': 'Beluga-Enterprise-Auth-Setup/1.0'
        },
        timeout: 10000
      }, (res) => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          this.log('SUCCESS', 'Supabase connection test passed');
          this.successes.push('Supabase service is accessible');
          resolve(true);
        } else {
          this.issues.push(`Supabase connection failed: HTTP ${res.statusCode}`);
          resolve(false);
        }
      });

      req.on('timeout', () => {
        this.issues.push('Supabase connection timeout');
        resolve(false);
      });

      req.on('error', (error) => {
        this.issues.push(`Supabase connection error: ${error.message}`);
        resolve(false);
      });

      req.end();
    });
  }

  async testProductionDomain() {
    this.log('INFO', 'Testing production domain accessibility...');

    if (!this.config.NEXT_PUBLIC_PRODUCTION_DOMAIN) {
      this.issues.push('Production domain not configured');
      return false;
    }

    return new Promise((resolve) => {
      const url = new URL(this.config.NEXT_PUBLIC_PRODUCTION_DOMAIN);

      const req = https.request({
        hostname: url.hostname,
        port: url.port || 443,
        path: url.pathname,
        method: 'GET',
        timeout: 10000,
        headers: {
          'User-Agent': 'Beluga-Enterprise-Auth-Setup/1.0'
        }
      }, (res) => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          this.log('SUCCESS', 'Production domain is accessible');
          this.successes.push('Production domain is live and accessible');
          resolve(true);
        } else {
          this.issues.push(`Production domain returned HTTP ${res.statusCode}`);
          resolve(false);
        }
      });

      req.on('timeout', () => {
        this.issues.push('Production domain timeout');
        resolve(false);
      });

      req.on('error', (error) => {
        this.issues.push(`Production domain error: ${error.message}`);
        resolve(false);
      });

      req.end();
    });
  }

  generateSetupReport() {
    const report = {
      timestamp: new Date().toISOString(),
      duration: Date.now() - this.startTime,
      environment: this.config.NODE_ENV,
      configuration: this.config,
      results: {
        successes: this.successes,
        warnings: this.warnings,
        issues: this.issues
      },
      recommendations: [],
      nextSteps: []
    };

    // Generate recommendations
    if (this.issues.length > 0) {
      report.recommendations.push('Fix all critical issues before deploying');
    }

    if (!this.config.GOOGLE_CLIENT_ID) {
      report.recommendations.push('Consider configuring Google OAuth for better user experience');
    }

    if (!process.env.NEXT_PUBLIC_SENTRY_DSN) {
      report.recommendations.push('Set up Sentry for production error monitoring');
    }

    // Generate next steps
    if (this.issues.length === 0) {
      report.nextSteps.push('Run production build: npm run build');
      report.nextSteps.push('Deploy to production platform (Vercel/Netlify)');
      report.nextSteps.push('Test authentication flow in production');
      report.nextSteps.push('Monitor authentication logs');
    } else {
      report.nextSteps.push('Fix all critical issues');
      report.nextSteps.push('Re-run this setup script');
      report.nextSteps.push('Test authentication system thoroughly');
    }

    return report;
  }

  saveReport(report) {
    const reportPath = path.join(process.cwd(), `production-auth-setup-${Date.now()}.json`);
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    this.log('INFO', `Setup report saved to: ${reportPath}`);
  }

  async run() {
    this.log('INFO', 'ðŸš€ Starting Enterprise Production Authentication Setup');
    this.log('INFO', `Environment: ${this.config.NODE_ENV || 'unknown'}`);

    try {
      // Load and validate configuration
      await this.loadConfig();
      const isConfigValid = this.validateConfig();

      // Create environment file
      const envFileCreated = this.createEnvFile();

      // Test connections
      const supabaseConnected = await this.testSupabaseConnection();
      const domainAccessible = await this.testProductionDomain();

      // Generate and save report
      const report = this.generateSetupReport();
      this.saveReport(report);

      // Display results
      this.log('INFO', 'ðŸ“Š SETUP RESULTS SUMMARY');

      if (this.successes.length > 0) {
        this.log('SUCCESS', 'âœ… Successes:');
        this.successes.forEach(success => console.log(`   âœ“ ${success}`));
      }

      if (this.warnings.length > 0) {
        this.log('WARNING', 'âš ï¸  Warnings:');
        this.warnings.forEach(warning => console.log(`   ! ${warning}`));
      }

      if (this.issues.length > 0) {
        this.log('ERROR', 'âŒ Issues:');
        this.issues.forEach(issue => console.log(`   âœ— ${issue}`));
      }

      // Final status
      const overallSuccess = this.issues.length === 0 && isConfigValid && envFileCreated;

      if (overallSuccess) {
        this.log('SUCCESS', 'ðŸŽ‰ PRODUCTION SETUP COMPLETE - Authentication system is ready for production!');
        this.log('INFO', 'ðŸš€ Next Steps:');
        report.nextSteps.forEach(step => console.log(`   â€¢ ${step}`));
      } else {
        this.log('CRITICAL', 'ðŸ’¥ SETUP INCOMPLETE - Fix issues before deploying');
        this.log('INFO', 'ðŸ”§ Required Actions:');
        report.recommendations.forEach(rec => console.log(`   â€¢ ${rec}`));
        process.exit(1);
      }

    } catch (error) {
      this.log('CRITICAL', 'Setup script failed with critical error', {
        error: error.message,
        stack: error.stack
      });
      process.exit(1);
    }
  }
}

// Run setup if called directly
if (require.main === module) {
  const setup = new ProductionAuthSetup();
  setup.run().catch((error) => {
    console.error('Setup failed:', error);
    process.exit(1);
  });
}

module.exports = { ProductionAuthSetup };
